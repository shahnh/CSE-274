/** * @author Nishil Shah */public final class ArrayQueue<T> implements QueueInterface<T>{	// To Do: Declare instance variables	private static final int DEFAULT_CAPACITY = 3; // Small capacity for testing	private static final int MAX_CAPACITY = 10000;	private int frontIndex, backIndex, numOfElement;	private T[] queue;	public ArrayQueue()	{		this(DEFAULT_CAPACITY);		numOfElement = 0;		frontIndex = 0;		backIndex = -1;	} // end default constructor	/**	 * initialize the Capacity that is giving by the user if it less than MAX_CAPACITY	 * @param initialCapacity	 */	public ArrayQueue(int initialCapacity)	{		if(initialCapacity < MAX_CAPACITY) {			queue = (T[]) new Object[initialCapacity];			numOfElement = 0;			frontIndex = 0;			backIndex = -1;		}	} // end constructor	/** Adds a new entry to the back of this queue.    @param newEntry  An object to be added. */	public void enqueue(T newEntry)	{		if((backIndex-frontIndex+1) == queue.length && 2*queue.length < MAX_CAPACITY) {			T[] temp = (T[]) new Object[queue.length * 2];			for(int i = 0; i < numOfElement; i++) {				temp[i] = queue[(frontIndex+i) % numOfElement];			}			queue = temp;			frontIndex = 0;			backIndex = numOfElement -1;		}		backIndex = (backIndex+1) % queue.length;		System.out.print("queue[" + backIndex % queue.length + "] = ");		System.out.println(queue[backIndex % queue.length] = newEntry);		numOfElement++;	} // end enqueue	/**  Retrieves the entry at the front of this queue.    @return  The object at the front of the queue.    @throws  EmptyQueueException if the queue is empty. */	public T getFront()	{		if(isEmpty())			throw new EmptyQueueException();		return queue[frontIndex];	} // end getFront	/** Removes and returns the entry at the front of this queue.    @return  The object at the front of the queue.     @throws  EmptyQueueException if the queue is empty before the operation. */	public T dequeue()	{		if(isEmpty())			throw new EmptyQueueException();		T returns = queue[frontIndex % queue.length];		queue[frontIndex % queue.length] = null;		frontIndex = (frontIndex + 1) % queue.length;		numOfElement--;		return returns;	} // end dequeue	/** Detects whether this queue is empty.    @return  True if the queue is empty, or false otherwise. */	public boolean isEmpty()	{		return numOfElement == 0;	} // end isEmpty	/** Removes all entries from this queue. */	public void clear()	{		queue = (T[]) new Object[queue.length];		numOfElement = 0;		frontIndex = 0;		backIndex = -1;	} // end clear}  // end ArrayQueue